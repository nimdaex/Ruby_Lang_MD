บทที่ 4 ออบเจ็คในภาษา Ruby  

ในบทนี้เนื้อหาจะลงลึกในแนวคิดเรื่อง **ออบเจ็ค** ในภาษา Ruby ซึ่งเป็นหัวใจหลักของภาษาเชิงวัตถุ โดยเฉพาะใน Ruby ที่ทุกอย่างในภาษา ไม่ว่าจะเป็นตัวเลข ข้อความ อาร์เรย์ โมดูล หรือแม้แต่เมธอดเอง ต่างก็จัดอยู่ในรูปของออบเจ็คทั้งสิ้น  การเข้าใจภาพนี้อย่างชัดเจนจะช่วยให้การเรียนเนื้อหาในบทถัดไป เช่น ตัวแปร ประเภทข้อมูล เมธอด หรือคลาสและการสืบทอด มีความต่อเนื่องและเข้าใจง่ายยิ่งขึ้น[1]

## Ruby กับแนวคิดออบเจ็ค  

ภาษา Ruby ถูกออกแบบมาให้เป็นภาษาเขียนโปรแกรมเชิงวัตถุอย่างเต็มรูปแบบ และรักษาความเรียบง่ายในการใช้งานพร้อมความสามารถในการจัดการข้อความที่ดีในระดับเดียวกับภาษาอย่าง Perl  ทุกค่าที่ปรากฏในโปรแกรม Ruby ไม่ว่าจะเป็นค่าคงที่ ตัวแปร หรือค่าที่เขียนเป็น literal ล้วนเป็นออบเจ็คจากคลาสใดคลาสหนึ่งเสมอ[1]

แนวคิดนี้หมายความว่า เมื่อคุณเขียนค่าบางอย่างลงไปในโปรแกรม เช่น ตัวเลขจำนวนเต็มหรือสตริง ตัวแปลภาษา Ruby จะมองสิ่งเหล่านั้นเป็น instance ของคลาสต่างๆ และเปิดให้สามารถเรียกเมธอดบนค่าดังกล่าวได้ทันที  ความคิดแบบ “ทุกอย่างคือออบเจ็ค” ทำให้ Ruby มีรูปแบบการเขียนโค้ดที่สม่ำเสมอ และช่วยให้สามารถใช้เมธอดและตัวดำเนินการได้อย่างยืดหยุ่น[1]

## ทุกอย่างคือออบเจ็ค  

ลองดูตัวอย่างการแสดงค่าประเภทต่างๆ ใน Ruby แล้วตรวจสอบคลาสของมัน:

```ruby
p  10
p  7.25
p  "Hello Ruby"
p  false
p  [4, 8, 12]
p  :token
```

แม้มุมมองจากภาษาอื่นอย่าง C, PHP หรือ Python บางเวอร์ชันจะเห็นสิ่งเหล่านี้เป็นเพียง literal ของชนิดข้อมูลพื้นฐาน แต่ใน Ruby สิ่งเหล่านี้คือออบเจ็คที่สามารถเรียกเมธอดได้  สามารถตรวจสอบคลาสของออบเจ็คเหล่านี้ด้วยเมธอด `class` ดังนี้[1]

```ruby
p  10.class
p  7.25.class
p  "Hello Ruby".class
p  false.class
p  [4, 8, 12].class
p  :token.class
```

ตัวอย่างข้างต้นใช้เมธอด `class` ซึ่งถูกเรียกผ่านจุด (`.`) ด้วยรูปแบบ `object.method` เพื่อดูว่าค่าแต่ละค่ามาจากคลาสใด  ผลลัพธ์จะแสดงคลาสเช่น `Integer`, `Float`, `String`, `FalseClass`, `Array` และ `Symbol` ให้เห็นอย่างชัดเจนว่า literal ทุกตัวเป็นออบเจ็คของคลาสที่เกี่ยวข้อง[1]

## การใช้เมธอดของออบเจ็คพื้นฐาน  

แต่ละออบเจ็คใน Ruby จะมีเมธอดจำนวนมากที่เตรียมไว้เพื่อใช้งานกับข้อมูลประเภทนั้นๆ เช่น การจัดการสตริง หรือการตรวจสอบคุณสมบัติของตัวเลข  ตัวอย่างด้านล่างแสดงให้เห็นการเรียกใช้เมธอดของออบเจ็คจากคลาส `String` และ `Integer` ที่ถูกเก็บไว้ในตัวแปร[1]

```ruby
message = "Ruby Objects"
p message.length      # ความยาวของข้อความ
p message.downcase    # แปลงเป็นตัวพิมพ์เล็ก
p message.upcase      # แปลงเป็นตัวพิมพ์ใหญ่
p message.reverse     # กลับด้านข้อความ

value = 18
p value.to_f          # แปลงเป็นจำนวนจริง
p value.to_s          # แปลงเป็นสตริง
p value.even?         # เป็นจำนวนคู่หรือไม่
p value.odd?          # เป็นจำนวนคี่หรือไม่
```

เมธอดอย่าง `length`, `downcase`, `upcase` และ `reverse` เป็นเมธอดที่คลาส `String` จัดเตรียมไว้ให้ เพื่อช่วยให้การจัดการสตริงทำได้ง่ายขึ้น  ในทำนองเดียวกัน `to_f`, `to_s`, `even?` และ `odd?` เป็นเมธอดในคลาส `Integer` ที่ช่วยให้การแปลงค่าและตรวจสอบคุณสมบัติตัวเลขเป็นเรื่องตรงไปตรงมา[1]

คุณสามารถดูรายชื่อเมธอดทั้งหมดที่ออบเจ็คหนึ่งๆ รองรับได้โดยเรียกเมธอด `methods` ซึ่งจะคืนค่าเป็นอาร์เรย์ของสัญลักษณ์ชื่อเมธอดทั้งหมด[1]

```ruby
p 10.methods
```

ผลลัพธ์จะแสดงรายชื่อเมธอดที่สามารถเรียกใช้ได้กับออบเจ็คประเภท `Integer` ซึ่งรวมทั้งเมธอดที่สืบทอดมาจากคลาสชั้นบนในลำดับชั้นของออบเจ็คด้วย[1]

## ตัวดำเนินการใน Ruby ก็เป็นเมธอด  

Ruby มีตัวดำเนินการที่หน้าตาคุ้นเคย เช่น `+`, `-`, `*`, `/`, `<`, `>`, `<=`, `>=` ซึ่งใช้งานกับตัวเลขและออบเจ็คอื่นเหมือนในภาษาโปรแกรมทั่วไป  ในมุมมองผิวเผิน ตัวดำเนินการเหล่านี้ดูเหมือนเครื่องหมายพิเศษที่ภาษาจัดการให้โดยตรง แต่ความจริงแล้วใน Ruby ตัวดำเนินการเหล่านี้ก็คือเมธอดชนิดหนึ่งของออบเจ็ค[1]

ตัวอย่างการใช้ตัวดำเนินการ:

```ruby
p  2 + 9      # 11
p  6 * 7      # 42
p  12 < 30    # true
```

หากเขียนในรูปแบบที่แสดงให้เห็นชัดเจนว่าเป็นการเรียกเมธอด จะได้โค้ดลักษณะนี้:

```ruby
p  2.+(9)     # 11
p  6.*(7)     # 42
p  12.<(30)   # true
```

คำสั่ง `2 + 9` และ `2.+(9)` มีความหมายเหมือนกัน คือเป็นการเรียกใช้เมธอด `+` บนออบเจ็ค `2` โดยมี `9` เป็นอาร์กิวเมนต์  Ruby อนุญาตให้ละวงเล็บ และละจุดหน้าชื่อเมธอดในกรณีที่เมธอดนั้นเป็นตัวดำเนินการ ซึ่งทำให้โค้ดอ่านได้สะดวกขึ้นในชีวิตจริง[1]

ตัวอย่างการเรียกเมธอดที่สามารถละวงเล็บได้:

```ruby
puts  3
puts(3)

puts "Go", "Rust", "Ruby"
puts("Go", "Rust", "Ruby")

"framework".upcase
"framework".upcase()
```

ในทุกกรณีที่แสดง เมธอดถูกเรียกด้วยผลลัพธ์เดียวกันต่างกันเพียงรูปแบบการเขียนว่าละวงเล็บหรือไม่เท่านั้น  การเขียนให้สอดคล้องกันในโปรเจ็กต์เดียวกันจะช่วยให้โค้ดอ่านง่ายและลดความสับสน[1]

## การเปลี่ยนพฤติกรรมของตัวดำเนินการ (method overriding)  

ในภาษา Ruby เมธอดที่ทำหน้าที่เป็นตัวดำเนินการก็สามารถถูกเขียนทับ (override) ได้เช่นเดียวกับเมธอดอื่นในคลาส  การทำเช่นนี้ทำให้สามารถปรับเปลี่ยนพฤติกรรมของตัวดำเนินการกับออบเจ็คบางประเภทได้ โดยแนวคิดนี้คล้ายกับ operator overloading ในภาษาอื่น[1]

ตัวอย่างการเปลี่ยนพฤติกรรมเมธอด `+` ในคลาส `Integer` (ตัวอย่างเชิงแนวคิด ไม่แนะนำให้ใช้จริงในโค้ด production):

```ruby
class Integer
  def +(other)
    self * other
  end
end

p  4 + 5
p  4.+(5)
```

เมื่อรันโค้ดนี้ การใช้ตัวดำเนินการ `+` กับออบเจ็คประเภท `Integer` จะไม่ได้ให้ผลลัพธ์เป็นการบวก แต่กลายเป็นการคูณแทน  ตัวอย่างนี้แสดงให้เห็นพลังของการเขียนทับเมธอดใน Ruby แต่ในทางปฏิบัติไม่ควรเปลี่ยนพฤติกรรมของคลาสพื้นฐานเช่น `Integer` ในโค้ดจริง เพราะจะทำให้โปรแกรมอ่านยากและเกิดบั๊กได้ง่าย[1]

แนวทางปฏิบัติที่เหมาะสมคือใช้การเขียนทับเมธอดกับคลาสที่กำหนดเอง โดยออกแบบให้ชัดเจนว่าตัวดำเนินการคาดหวังให้ทำอะไรกับออบเจ็คประเภทนั้น เช่น การบวกระยะทาง การรวมเวกเตอร์ หรือการเชื่อมข้อมูลเชิงโครงสร้าง[1]

## การสร้างออบเจ็คแบบ implicit และ explicit  

การสร้างออบเจ็คใน Ruby ทำได้สองแนวทางใหญ่ คือการใช้ literal เพื่อให้ตัวแปลภาษาสร้างออบเจ็คให้อัตโนมัติ และการสร้างออบเจ็คผ่านคลาสโดยตรงด้วยเมธอด `new`  แนวทางแรกเรียกว่า implicit ส่วนแนวทางที่สองเรียกว่า explicit[1]

### การสร้างออบเจ็คแบบ implicit ด้วย literal  

ตัวอย่างการสร้างออบเจ็คด้วย literal:

```ruby
count    = 24
language = "Ruby"
prices   = [150, 200, 450]
flag     = true
```

ในตัวอย่างนี้ `24`, `"Ruby"`, `[150, 200, 450]` และ `true` เป็น literal ที่ Ruby แปลงเป็นออบเจ็คของคลาส `Integer`, `String`, `Array` และ `TrueClass` ตามลำดับ  รูปแบบนี้คือสิ่งที่ใช้บ่อยที่สุดในโค้ดทั่วไปเพราะกระชับและอ่านง่าย[1]

### การสร้างออบเจ็คแบบ explicit ด้วยคลาสและเมธอด `new`  

ในอีกแบบหนึ่ง สามารถสร้างออบเจ็คจากคลาสโดยตรง เช่น `String` หรือ `Array` ด้วยเมธอด `new`[1]

```ruby
nickname = String.new("CoderX")
queue    = Array.new
queue.push("task1", "task2", "task3")

puts nickname
puts queue
puts nickname.class
puts queue.class
```

ตัวแปร `nickname` เป็นออบเจ็คจากคลาส `String` ที่ถูกสร้างด้วย `String.new` พร้อมค่าเริ่มต้น `"CoderX"` ขณะที่ `queue` เป็นออบเจ็คจากคลาส `Array` ที่สร้างด้วย `Array.new` แล้วค่อยเพิ่มค่าเข้าไปภายหลังด้วยเมธอด `push`  อย่างไรก็ตาม คลาสบางประเภท เช่น `Integer`, `Float` หรือ `Symbol` ไม่รองรับการสร้างออบเจ็คด้วย `new` และควรถูกสร้างผ่าน literal เท่านั้น[1]

## สร้างคลาสเองและนำไปสร้างออบเจ็ค  

นอกจากใช้คลาสที่มากับภาษาแล้ว Ruby ยังให้สร้างคลาสของตนเองได้อย่างอิสระ เพื่อใช้อธิบายออบเจ็คที่สอดคล้องกับแนวคิดในโดเมนของโปรแกรม เช่น คน สินค้า รถยนต์ หรือคำสั่งซื้อ[1]

ตัวอย่างคลาสพื้นฐานที่สุดที่สร้างขึ้นเอง:

```ruby
class Entity
end

e = Entity.new
puts e
# puts e.object_id  # สามารถใช้ดูรหัสอ้างอิงของออบเจ็คได้
```

แม้คลาส `Entity` จะไม่มีเมธอดหรือคุณสมบัติใดๆ ระบุไว้ แต่ Ruby จะให้คลาสนี้สืบทอดมาจาก `Object` โดยอัตโนมัติ ทำให้ออบเจ็คที่สร้างจากคลาสนี้สามารถใช้เมธอดพื้นฐานอย่าง `object_id`, `inspect`, และเมธอดอื่นๆ จากลำดับชั้นของออบเจ็คได้[1]

### คลาสที่มีคอนสตรัคเตอร์และเมธอดทำงานจริง  

ตัวอย่างคลาสที่มีตัวแปร instance และเมธอดที่ใช้งานได้จริง เช่น “ผู้ใช้งานระบบ”:

```ruby
class User
  def initialize(username, role, joined_year)
    @username    = username
    @role        = role
    @joined_year = joined_year
  end

  def profile
    "User #{@username} (#{@role}), joined in #{@joined_year}"
  end
end

u1 = User.new("alice_dev",  "admin",   2021)
u2 = User.new("bob_ops",   "operator", 2020)
u3 = User.new("cara_view", "viewer",   2023)

puts "User profiles"
puts u1.profile
puts u2.profile
puts u3.profile
```

เมธอด `initialize` ทำหน้าที่เป็นคอนสตรัคเตอร์ที่ถูกเรียกอัตโนมัติเมื่อใช้ `User.new` เพื่อสร้างออบเจ็คใหม่ โดยรับพารามิเตอร์แล้วเก็บลงในตัวแปร instance (`@username`, `@role`, `@joined_year`) ของออบเจ็ค  เมธอด `profile` ใช้ข้อมูลในตัวแปร instance มาประกอบเป็นสตริงบรรยายรายละเอียดของผู้ใช้แต่ละคน ซึ่งแสดงให้เห็นว่าทุกออบเจ็คที่สร้างจากคลาสเดียวกันสามารถมีค่าภายในที่แตกต่างกันได้[1]

สามารถขยายแนวคิดนี้ไปสร้างคลาสอื่น เช่น “งานที่ต้องทำ” หรือ “คำสั่งซื้อสินค้า”:

```ruby
class Task
  def initialize(title, priority, done = false)
    @title    = title
    @priority = priority
    @done     = done
  end

  def mark_done
    @done = true
  end

  def info
    status = @done ? "completed" : "pending"
    "[#{@priority}] #{@title} (#{status})"
  end
end

t1 = Task.new("Implement login API", "high")
t2 = Task.new("Write test cases",    "medium")
t3 = Task.new("Refactor helpers",    "low")

t2.mark_done

puts t1.info
puts t2.info
puts t3.info
```

โค้ดนี้แสดงการใช้เมธอด instance เพื่อเปลี่ยนสถานะของออบเจ็ค (`mark_done`) และแสดงข้อมูล (`info`) โดยแต่ละออบเจ็คจะเก็บสถานะของตัวเองแยกจากกันในตัวแปร instance[1]

## Ruby object hierarchy และการสืบทอดจาก Object  

ออบเจ็คทุกชนิดใน Ruby มีรากฐานจากคลาส `Object` ซึ่งอยู่ด้านล่างสุดของลำดับชั้นของออบเจ็คทั่วไป (ไม่นับระดับที่ลึกกว่านี้อย่าง `BasicObject`)  แนวคิดการสืบทอดทำให้คลาสลูกได้รับเมธอดและคุณสมบัติต่างๆ จากคลาสแม่โดยอัตโนมัติ[1]

ลองพิจารณาตัวอย่างต่อไปนี้:

```ruby
puts  3.inspect
puts  9.75.inspect
puts  "marcuscode".inspect

puts  3.class
puts  9.75.class
puts  "marcuscode".class
```

เมธอด `inspect` ใช้แสดงรูปแบบภายในของออบเจ็คเป็นสตริง ส่วนเมธอด `class` แสดงว่าค่าแต่ละค่าถูกสร้างมาจากคลาสใด  เมธอดเหล่านี้ไม่ได้ถูกกำหนดอยู่ใน `Integer`, `Float` หรือ `String` โดยตรง แต่สืบทอดมาจากคลาส `Object` ที่อยู่สูงขึ้นไปในลำดับชั้นของออบเจ็ค[1]

### ตัวอย่างคลาสที่สืบทอดคุณสมบัติจาก Object  

สร้างคลาสเก็บจุดสองมิติ และใช้เมธอดของ `Object` ตรวจสอบลักษณะของออบเจ็ค:

```ruby
class Point2D
  attr_accessor :x, :y

  def initialize(x, y)
    @x = x
    @y = y
  end

  def self.distance(a, b)
    Math.sqrt((b.x - a.x) ** 2 + (b.y - a.y) ** 2)
  end
end

p1 = Point2D.new(2, 4)
p2 = Point2D.new(7, 10)

puts p1.inspect
puts p2.inspect
puts Point2D.distance(p1, p2)

puts p1.instance_of?(Point2D)
puts p1.kind_of?(Object)
```

เมธอด `instance_of?` ใช้ตรวจสอบว่าออบเจ็คถูกสร้างมาจากคลาสใดโดยตรง ส่วน `kind_of?` ใช้ดูว่าออบเจ็คเป็นสมาชิกของคลาสหรือซับคลาสใดในลำดับชั้นที่สืบทอดจากกัน  ผลลัพธ์ที่เป็น `true` จาก `kind_of?(Object)` แสดงให้เห็นว่าคลาส `Point2D` และออบเจ็คที่สร้างจากมันก็สืบทอดมาจาก `Object` เช่นกัน[1]

หากต้องการเพิ่มเมธอดเพิ่มเติมในคลาสที่กำหนดเอง ก็สามารถใช้เมธอดจาก `Object` ร่วมกับเมธอดที่เขียนขึ้นเองได้อย่างกลมกลืน เช่นเมธอด `object_id`, `to_s`, หรือ `==`[1]

## Ruby top-level และออบเจ็ค `main`  

ในโปรแกรม Ruby ส่วนโค้ดที่อยู่ “ด้านนอกสุด” ของคลาสหรือโมดูล เรียกว่า top-level และในบริบทนี้ Ruby จะมีออบเจ็คหลักตัวหนึ่งชื่อ `main` ทำหน้าที่เป็นออบเจ็คปัจจุบันที่โค้ดกำลังทำงานอยู่  ออบเจ็ค `main` นี้เองที่เป็น instance ของคลาส `Object` จึงสามารถเรียกเมธอดต่างๆ จาก `Object` และจากโมดูลที่รวมเข้าไปใน `Object` ได้[1]

ตัวอย่างโค้ดใน top-level:

```ruby
a = 2
b = 7

puts local_variables
Kernel.puts self
puts self.class
```

สองบรรทัดแรกประกาศตัวแปร `a` และ `b` ในขอบเขตของ top-level ซึ่งถือเป็น local variables ในออบเจ็ค `main`  เมธอด `local_variables` ใช้สำหรับดึงรายชื่อของตัวแปรท้องถิ่นในบริบทปัจจุบัน ส่วน `self` อ้างถึงออบเจ็ค `main` ซึ่งเมื่อนำไปแสดงด้วย `puts` จะเห็นชื่อ `main` ปรากฏขึ้น[1]

เมธอด `puts` ที่ถูกเรียกใช้งานนั้นอยู่ในโมดูล `Kernel` ซึ่งถูก include ไว้ในคลาส `Object` ทำให้สามารถเรียกใช้ได้ทันทีโดยไม่ต้องเขียน `Kernel.` ข้างหน้าใน top-level  การเรียก `self.class` จะแสดงให้เห็นว่า top-level นั้นมีคลาสเป็น `Object` เช่นเดียวกัน[1]

### ตัวแปร instance และเมธอดใน top-level  

นอกจากตัวแปร local แล้ว ยังสามารถสร้างตัวแปร instance และเมธอด instance ที่สังกัดอยู่กับออบเจ็ค `main` ใน top-level ได้[1]

```ruby
@site_name = "DevLab"
@version   = 1.3

def info
  "#{@site_name} version #{@version}"
end

puts self.instance_variables
puts self.private_methods.include?(:info)
puts info
```

ในตัวอย่างนี้ `@site_name` และ `@version` เป็นตัวแปร instance ที่ผูกติดกับออบเจ็ค `main` เช่นเดียวกับเมธอด `info` ที่กลายเป็น private method ของออบเจ็ค `main`  เมธอด `instance_variables` ใช้แสดงรายชื่อของตัวแปร instance ทั้งหมดในบริบทปัจจุบัน ส่วน `private_methods` คืนค่าอาร์เรย์ของเมธอด private ทั้งหมด ทำให้ตรวจสอบได้ว่ามีเมธอด `info` อยู่ในนั้นหรือไม่[1]

การเรียก `info` ในท้ายสุดเป็นการเรียกเมธอดของ top-level โดยตรง แสดงผลรวมของข้อมูลที่เก็บไว้ในตัวแปร instance ให้เห็นว่าเมธอดนี้เป็นส่วนหนึ่งของออบเจ็ค `main` เช่นกัน[1]

## ภาพรวมการทำงานร่วมกันของออบเจ็คในโปรแกรม Ruby  

เมื่อผสานทุกแนวคิดของบทนี้เข้าด้วยกัน จะเห็นภาพว่าโปรแกรม Ruby หนึ่งโปรแกรมถูกประกอบขึ้นจากออบเจ็คจำนวนมาก ทั้งที่สร้างจาก literal, ออบเจ็คที่สร้างผ่านคลาสมาตรฐานของภาษา และออบเจ็คที่มาจากคลาสที่ผู้พัฒนาออกแบบเอง  ตัวดำเนินการต่างๆ ก็ทำหน้าที่เป็นเมธอดบนออบเจ็คเช่นกัน และทุกออบเจ็คในโปรแกรมจะอยู่ภายใต้ลำดับชั้นที่มีคลาส `Object` เป็นฐานร่วมกัน[1]

ในขณะเดียวกัน top-level ของโปรแกรมก็เป็นออบเจ็ค `main` ที่อยู่ภายใต้คลาส `Object` ทำหน้าที่ห่อหุ้มโค้ดส่วนที่ไม่อยู่ในคลาสหรือโมดูลใดๆ ให้สามารถอ้างถึงตัวแปรและเมธอดได้อย่างเป็นระบบ  การเข้าใจว่าทุกสิ่งที่กำลังทำงานอยู่ใน Ruby ล้วนเป็นออบเจ็คที่สัมพันธ์กันผ่านลำดับชั้นของคลาส จะเป็นพื้นฐานสำคัญเมื่อเข้าสู่บทถัดไปเกี่ยวกับตัวแปร ประเภทข้อมูล คลาส การสืบทอด และคุณสมบัติอื่นของการเขียนโปรแกรมเชิงวัตถุในภาษา Ruby[1]

[1](https://marcuscode.com/lang/ruby/objects)